Name words
; Сегмент данных: строки, указатели и вспомогательные данные
data segment
db "Scepticism",9,"$";
db "acceptance",9,"$"
db "yellowwood",9,"$"
db "Conversion",9,"$"
db "management",9,"$"
db "Corruption",9,"$"
db "depression",9,"$"
db "collection",9,"$"
db "investment",9,"$"
db "assembling",9,"$"
db "Management",9,"$"
db "conversion",9,"$"
db "obligation",9,"$"
db "prospectus",9,"$"
db "Collection",9,"$"
db "securities",9,"$"
db "Investment",9,"$"
db "typewriter",9,"$"
db "Validation",9,"$"
db "xenogenies",9,"$"

; Смещения начала каждой строки 
stringarr dw 0,12,24,36,48,60,72,84,96,108,120,132,144,156,168,180,192,204,216,228
; Количество строк в массиве
stringnum dw 20
; Вывод заголовков
array db 'Array:',13,10,'$'
result db 13,10,'Result:',13,10,'$'
data ends

; Сегмент стека: используется для временного хранения данных
stacks segment word stack 'stack'
; Выделение 200 слов для стека
dw 200 dup(?) 
; Указатель на вершину стека
StackTop:
stacks ends 

; Сегмент кода программы
code segment
; Указываем, что CS, DS, ES, SS указывают на свои сегменты
assume CS: code, DS: data, ES: data, SS: stacks

; Процедура PrintStrings: выводит на экран строки из массива
PrintStrings proc
    push bp         ; Сохраняем базовый указатель
    mov bp,sp       ; Устанавливаем стек-кадр
    push si         ; Сохраняем регистр SI
    push di         ; Сохраняем регистр DI
    push dx         ; Сохраняем регистр DX
    push cx         ; Сохраняем регистр DI

    mov si,[bp+4]	; Указатель на массив строк (stringarr)
    mov di,[bp+6]	; Указатель на количество строк (stringnum)
    mov cx,[di]     ; Количество строк

   print:
    mov dx,[si]		; Адрес текущей строки
    mov ah,09h		; Функция DOS (09h - вывод строки)
    int 21h         ; Вызов DOS для вывода строки
    add si,2        ; Переход к следующему указателю в stringarr
    loop print      ; Уменьшаем CX и повторяем цикл, если CX > 0

    pop cx		    ; Восстанавливаем регистр CX
    pop dx          ; Восстанавливаем регистр DX
    pop di          ; Восстанавливаем регистр DI
    pop si          ; Восстанавливаем регистр SI
    pop bp          ; Восстанавливаем базовый указатель
    ret 4           ; Выход из процедуры
PrintStrings endp

; Процедура Compare2Strings: сравнивает две строки
Compare2Strings proc
    push bp         ; Сохраняем базовый указатель
    mov bp,sp       ; Устанавливаем стек-кадр
    push si         ; Сохраняем регистр SI
    push di         ; Сохраняем регистр DI
    push cx         ; Сохраняем регистр CX
    push dx         ; Сохраняем регистр DX

    mov si,[bp+4]	; SI = указатель на первую строку
    mov di,[bp+6]	; DI = указатель на вторую строку
    mov cx,10		; CX = количество символов сравнения

   startcom:
    lodsb		    ; Загружаем текущий символ первой строки в AL
    cmp al,'a'		; Проверяем, меньше ли символ 'a'
    jb readsymstr2  ; Если меньше, пропускаем преобразование
    cmp al,'z'      ; Проверяем, больше ли символ 'z'
    ja readsymstr2  ; Если больше, пропускаем преобразование
    sub al,20h		; Преобразуем символ в верхний регистр

    readsymstr2:
    mov ah,[di]		; Загружаем символ второй строки в AH
    inc di          ; Увеличиваем DI для перехода к следующему символу
    cmp ah,'a'		; Проверяем, меньше ли символ 'a'
    jb comparesym   ; Если меньше, пропускаем преобразование
    cmp ah,'z'      ; Проверяем, больше ли символ 'z'
    ja comparesym   ; Если больше, пропускаем преобразование
    sub ah,20h		; Преобразуем символ в верхний регистр

    comparesym:
    cmp al,ah		; Сравниваем символы
    jz nextsym		; Если равны, переходим к следующему
    ja above		; Если первый символ больше, переходим к "above"
    mov al,1		; Устанавливаем результат = 1 (меньше)
    jmp exit

   above:
    mov al,2	    ; Устанавливаем результат = 2 (больше)	
    jmp exit

   nextsym:
    loop startcom   ; Повторяем цикл для всех символов
    mov al,0		; Если строки равны, результат = 0

   exit:
    pop dx		    ; Восстанавливаем регистр DX
    pop cx          ; Восстанавливаем регистр CX
    pop di          ; Восстанавливаем регистр DI
    pop si          ; Восстанавливаем регистр SI
    pop bp          ; Восстанавливаем базовый указатель
    ret 4           ; Выход из процедуры
Compare2Strings endp

; Процедура RemoveDuplicate: удаляет дублирующую строку
RemoveDuplicate proc
    push bp         ; Сохраняем базовый указатель
    mov bp,sp       ; Устанавливаем стек-кадр
    push si         ; Сохраняем регистр SI
    push di         ; Сохраняем регистр DI

    mov di,[bp+8]	; DI = указатель на stringnum
    mov ax,[di]     ; AX = количество строк
    dec ax          ; Уменьшаем количество строк
    mov [di],ax     ; Обновляем stringnum

    mov si,[bp+6]	; SI = конец массива строк
    mov di,[bp+4]	; DI = текущая строка

    cmp si,di       ; Проверка, достигнут ли конец массива       
    jz exitdup		; Если достигнут, выходим

   moving:           
    mov ax,[di+2]	; Копируем следующую строку в текущую
    mov [di],ax
    add di,2		; Переходим к следующей строке
    cmp di,si		; Проверяем, достигнут ли конец массива
   jb moving		; Если нет, продолжаем

   exitdup:
    pop di		    ; Восстанавливаем регистр DI
    pop si          ; Восстанавливаем регистр SI
    pop bp          ; Восстанавливаем базовый указатель
    ret 6           ; Выход из процедуры
RemoveDuplicate endp

; Процедура SortStrings: сортирует строки в массиве stringarr в алфавитном порядке
SortStrings proc
    push bp		    ; Сохраняем базовый указатель
    mov bp,sp       ; Устанавливаем стек-кадр
    push si         ; Сохраняем регистр SI
    push di         ; Сохраняем регистр DI
    push cx         ; Сохраняем регистр CX
    push bx         ; Сохраняем регистр BX
    push dx         ; Сохраняем регистр DX

    mov si,[bp+4]	; SI = указатель на начало массива строк (stringarr)
    mov di,[bp+6]   ; DI = указатель на количество строк (stringnum)
    mov ax,[di]		; AX = количество строк 
    dec ax          ; AX = количество строк - 1 (для границ сортировки)
    shl ax,1        ; Умножаем AX на 2 (каждый указатель занимает 2 байта)
    mov dx,si		; DX = начало массива строк
    add dx,ax       ; DX = конец массива строк

   sort:
    mov di,si       ; DI = указатель на текущую строку (начало текущего прохода)
    add di,2        ; DI = указатель на следующую строку

   sort2:
    push [di]       ; Сохраняем указатель на строку 2
    push [si]       ; Сохраняем указатель на строку 1

    ; Вызов процедуры сравнения строк
    call Compare2Strings

    cmp al,0 		; Проверяем результат сравнения
    jne check1		; Если строки не равны, переходим к следующей проверке

    ; Удаление дублирующейся строки
    push [bp+6]     ; Передаем указатель на stringnum
    push dx         ; Передаем конец массива строк
    push di         ; Передаем указатель на дублирующуюся строку

    ; Вызов процедуры удаления дублирующейся строки
    call RemoveDuplicate

    sub dx,2		; Сдвигаем конец массива строк
    cmp di,dx		; Проверяем, достиг ли DI конца массива
    jbe sort2       ; Если нет, продолжаем сортировку

    jmp exitremove  ; Переходим к завершению процедуры

   check1:
    cmp al,1	    ; Проверяем, первая строка меньше второй?	
    jne next        ; Если нет, переходим к следующей строке

    ; Обмен строк местами
    mov bx,[di]		; BX = указатель на строку 2
    mov cx,[si]     ; CX = указатель на строку 1
    mov [di],cx     ; Меняем местами указатели строк
    mov [si],bx     ; Завершаем обмен

   next:
    add di,2        ; DI = следующая строка
    cmp di,dx		; Проверка, достиг ли DI конца массива
    jbe sort2       ; Если нет, продолжаем сортировку текущего прохода

    add si,2		; SI = следующая строка для нового прохода
    cmp si,dx	    ; Проверка, достиг ли SI конца массива
    jb sort         ; Если нет, продолжаем сортировку

   exitremove:
    pop dx		    ; Восстанавливаем регистр DX
    pop bx          ; Восстанавливаем регистр BX
    pop cx          ; Восстанавливаем регистр CX
    pop di          ; Восстанавливаем регистр DI
    pop si          ; Восстанавливаем регистр SI
    pop bp          ; Восстанавливаем базовый указатель
    ret 4           ; Выход из процедуры
SortStrings endp

; Начало выполнения программы
start: 
    mov sp,offset StackTop  ; Инициализация указателя стека (SP) на вершину стека

    ; Инициализация сегментов данных
    mov ax,data             
    mov ds,ax		
    mov es,ax		

    ; Вывод заголовка "Array:"
    mov dx,offset array     ; DX = адрес строки
    mov ah,09h		        ; Функция DOS (09h - вывод строки)
    int 21h                 ; Вызов DOS для вывода строки

    ; Вывод массива строк перед сортировкой
    lea ax,stringnum        ; AX = адрес количества строк
    push ax		            ; Передаем адрес количесвта строк в стек
    lea ax,stringarr        ; AX = адрес массива строк
    push ax		            ; Передаем адрес массива строк в стек
    call PrintStrings	    ; Вызов процедуры PrintStrings

    ; Вывод заголовка "Result:"
    mov dx,offset result    ; DX = адрес строки
    mov ah,09h		        ; Функция DOS (09h - вывод строки)
    int 21h                 ; Вызов DOS для вывода строки

    ; Сортировка массива строк
    lea ax,stringnum        ; AX = адрес количества строк
    push ax		            ; Передаем адрес количесвта строк в стек
    lea ax,stringarr        ; AX = адрес массива строк
    push ax		            ; Передаем адрес массива строк в стек
    call SortStrings	    ; Вызов процедуры SortStrings

    ; Вывод массива строк после сортировки
    lea ax,stringnum        ; AX = адрес количества строк
    push ax		            ; Передаем адрес количества строк в стек
    lea ax,stringarr        ; AX = адрес массива строк
    push ax		            ; Передаем адрес массива в стек
    call PrintStrings	    ; Вызываем процедуру PrintStrings

    ; Завершение программы
    mov ax,4c00h	        ; Функция DOS (4Ch - завершение программы)
    int 21h                 ; Вызов DOS для завершения программы

code ends
end start